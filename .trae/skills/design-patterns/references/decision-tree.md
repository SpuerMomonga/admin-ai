# 模式选择决策树

按问题信号从上到下判断，命中即优先考虑对应模式；若多个命中，组合使用时以“最小抽象”为原则。

## 1) 变化点在哪里？

- **同一行为多实现，运行期可切换** → Strategy
- **创建逻辑复杂或按类型/配置创建不同实现** → Factory / Abstract Factory
- **对接第三方/遗留接口，内部想统一契约** → Adapter
- **需要叠加横切能力且可组合** → Decorator
- **核心流程与副作用解耦（通知、统计、异步任务）** → Event/Observer
- **把操作作为对象，便于队列/重试/审计** → Command

## 2) 依赖与边界是否清晰？

- **业务层直接依赖 ORM/SDK** → 引入 Repository/Client 接口 + DI
- **跨模块互相调用内部实现** → 明确公开接口（Facade/Module API）+ DTO

## 3) 扩展方式是什么？

- **新增一种实现**：应只新增类/文件，不修改大量 if/else → Strategy/Factory
- **新增一种能力**：应通过组合包装，不侵入核心实现 → Decorator
- **新增一种副作用**：应通过新增订阅者实现 → Event/Observer

## 4) 何时不要引入模式？

- 变化点未出现，仅凭想象提前抽象
- if/else 分支数量很小且稳定，且替换成本低
- 团队对抽象约定不一致，导致维护成本高于收益

## 最小可行抽象检查

- 抽象是否隐藏了真实差异，导致“看似统一但处处特判”
- 是否引入了难以追踪的隐式依赖（全局单例、Service Locator）
- 是否能用函数/数据结构替代类层级（优先简单方案）

