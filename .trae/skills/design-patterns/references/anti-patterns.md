# 反模式识别指南

用以下清单在设计与重构时做自检，发现命中项优先纠偏。

## God Object（上帝对象）

**信号**：单个类/模块承担过多职责；改一处牵一片；测试困难。

**纠偏**：按“用例/职责/边界依赖”拆分；把 I/O 与纯逻辑剥离。

## Spaghetti Dependencies（依赖乱麻）

**信号**：模块之间双向依赖、循环 import、跨层直连。

**纠偏**：统一依赖方向；引入接口（DIP）与 DTO；抽出 shared 的基础能力。

## Singleton Abuse（滥用单例/全局状态）

**信号**：测试互相污染、并发不稳定、状态难追踪。

**纠偏**：改为显式依赖注入；将状态下沉为请求级/事务级对象。

## Boolean Parameter（布尔参数控制分支）

**信号**：`doX(flag)` 产生隐式模式，调用点难读，分支不断膨胀。

**纠偏**：拆分为两个明确函数，或使用 Strategy/Command。

## Anemic Domain Model（贫血领域模型）

**信号**：领域对象只存数据，所有规则都在 Service；规则分散且重复。

**纠偏**：把不依赖 I/O 的规则回收到领域对象/值对象；Service 负责编排与边界。

## Premature Abstraction（过早抽象）

**信号**：抽象层很多但实现很少；处处“特判”；理解成本高。

**纠偏**：回退到直接实现；等出现真实变化点再抽象。

## Inheritance Overuse（过度继承）

**信号**：深继承树、父类改动影响面大、覆写组合难预测。

**纠偏**：优先组合（Decorator/Strategy）；继承只用于稳定的 is-a 关系。

## Hidden I/O（隐式 I/O）

**信号**：看似纯函数但内部访问 DB/网络/全局缓存；性能与失败模式不可预期。

**纠偏**：显式划分纯逻辑与 I/O；I/O 放在边界依赖中并注入。

