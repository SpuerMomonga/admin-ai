# 单元测试编写规范

## 目标

- 用最小依赖验证业务规则与边界条件
- 测试失败时能快速定位问题原因
- 测试代码本身可维护、可读、可重构

## 范围与边界

- 适用于：纯函数、领域规则、服务层中可隔离的逻辑分支、错误映射与校验逻辑
- 不适用于：真实数据库/网络/消息队列交互（改用集成测试或契约测试）

## 结构约定

- 用例采用 AAA：Arrange（准备）/ Act（执行）/ Assert（断言）
- 单个用例只验证一个“行为点”，多个行为点拆分为多个用例
- 用例命名必须体现：
  - 前置条件（Given）
  - 动作（When）
  - 期望结果（Then）

示例命名风格（语言无关）：

- `givenValidInput_whenCalculate_thenReturnExpectedTotal`
- `givenMissingField_whenValidate_thenThrowValidationError`

## 断言原则

- 断言行为，不断言实现细节（避免对私有方法、内部调用顺序做强绑定）
- 断言要“足够具体”：
  - 返回值：关键字段
  - 错误：错误类型/错误码/错误消息片段（避免强依赖全文）
  - 副作用：调用次数、写入内容（仅在确有必要时）
- 对浮点/时间/集合顺序等不稳定结果使用容差与无序断言

## Mock / Stub / Fake 指南

- 优先使用真实对象 + 边界隔离；必要时再 Mock
- Mock 的对象应是“边界依赖”（例如 Repository/Client/Clock），而不是业务对象本身
- 只 Mock 自己拥有的接口，不直接 Mock 第三方库的深层内部结构
- 避免过度 Mock：
  - 过度 Mock 会导致测试绑定实现，重构成本高
  - 更倾向注入接口（Repository/Client/Clock/IdGenerator）以获得可测性

## 常见陷阱与修复

- **不确定性**（当前时间、随机数、并发调度）
  - 注入 `Clock` / `Random` / `IdGenerator`；或通过可控种子固定
- **共享状态污染**（全局单例、缓存、环境变量）
  - 每个用例前后显式 reset；避免并行用例互相影响
- **脆弱的快照**（UI/序列化快照）
  - 快照只覆盖稳定输出；对动态字段做规范化或剔除

## 最小用例表模板

| 用例 | 输入 | 前置状态 | 期望输出 | 期望错误 | 备注 |
|---|---|---|---|---|---|
| 正常 | ... | ... | ... | 无 | 关键路径 |
| 边界 | ... | ... | ... | 无/有 | 极值/空集合 |
| 异常 | ... | ... | ... | 某错误码 | 缺字段/非法值 |

