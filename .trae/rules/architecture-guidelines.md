# 架构设计指南 (Architecture Design Guidelines)

本文档概述了项目的核心架构原则，旨在构建高内聚、低耦合、可扩展且易于维护的系统。

## 目录

- [1. 分层架构规范](#1-分层架构规范-layered-architecture)
  - [1.1 表现层](#11-表现层-presentation-layer--interface-layer)
  - [1.2 业务逻辑层](#12-业务逻辑层-business-logic-layer--service-layer)
  - [1.3 数据访问层](#13-数据访问层-data-access-layer--infrastructure-layer)
  - [1.4 跨层依赖与边界](#14-跨层依赖与边界)
- [2. 模块划分原则](#2-模块划分原则-module-partitioning)
- [3. 接口设计标准](#3-接口设计标准-interface-design)
- [4. 数据流管理方案](#4-数据流管理方案-data-flow-management)
- [5. 扩展性设计考虑](#5-扩展性设计考虑-extensibility-design)
- [6. 常见反例与纠偏](#6-常见反例与纠偏)

## 1. 分层架构规范 (Layered Architecture)

采用标准的分层架构模式，明确各层职责，禁止跨层调用（如下层调用上层）。

### 1.1 表现层 (Presentation Layer / Interface Layer)
- **职责**: 处理用户交互、接收请求、参数校验、返回响应。
- **组件**: API Controllers, CLI Commands, UI Components.
- **原则**: 
  - 不包含复杂的业务逻辑。
  - 仅负责数据的输入输出格式转换。
  - 统一做鉴权/限流/参数校验（或调用统一中间件/过滤器），不要把这些逻辑散落在业务层。

### 1.2 业务逻辑层 (Business Logic Layer / Service Layer)
- **职责**: 实现核心业务规则、工作流编排、领域模型处理。
- **组件**: Services, Use Cases, Domain Models.
- **原则**: 
  - 纯净的业务逻辑，尽量不依赖具体的技术框架（如 HTTP 框架）。
  - 负责事务管理。
  - 通过接口依赖基础设施（Repository / Client），避免直接依赖具体实现。

### 1.3 数据访问层 (Data Access Layer / Infrastructure Layer)
- **职责**: 与外部系统（数据库、消息队列、外部 API）交互。
- **组件**: Repositories, DAOs, API Clients.
- **原则**: 
  - 封装底层存储细节。
  - 向业务层提供抽象接口，而非具体的数据库实现（如 SQLAlchemy model）。
  - 外部调用统一做超时、重试（有上限/退避）、熔断/降级（按需要），并输出可观测信息（脱敏）。

### 1.4 跨层依赖与边界

- **依赖方向**: 表现层 → 业务层 → 数据访问层。禁止反向依赖与跨层直连。
- **边界模型**:
  - 层与层之间用 DTO/请求对象/响应对象传递，避免直接暴露数据库实体或外部 SDK 对象。
  - 在边界处做错误翻译：底层异常 → 业务异常/统一错误码，避免将底层错误信息泄露给上层或用户。
- **事务边界**: 事务（或一致性控制）由业务层负责，数据访问层不自行开启跨业务的事务。

---

## 2. 模块划分原则 (Module Partitioning)

- **单一职责原则 (SRP)**: 每个模块应只负责一个特定的功能领域。
- **高内聚**: 相关的类和函数应组织在同一个模块中。
- **低耦合**: 模块之间的依赖关系应尽可能少且单向。
- **按功能特性分包 (Package by Feature)**: 优先按业务功能（如 `users`, `orders`, `billing`）而不是按技术层级（如 `controllers`, `services`, `models`）来组织代码结构。
  - 推荐结构示例（按功能特性分包，层次在 feature 内收敛）：
    - `users/`：`controller`/`service`/`repository`/`dto`/`errors`
    - `billing/`：`service`/`gateway`/`dto`/`events`
  - 跨模块共享能力放在 `shared/`（如日志、错误基类、配置、工具库），但避免把业务逻辑堆进 shared。

---

## 3. 接口设计标准 (Interface Design)

- **契约优先**: 在实现之前定义清晰的接口契约 (Interface/Protocol)。
- **RESTful API**:
  - 遵循 REST 语义 (GET, POST, PUT, DELETE)。
  - 资源导向的 URL 设计 (e.g., `/api/users/{id}/orders`).
  - 使用标准 HTTP 状态码。
  - 明确幂等性：对外接口注明是否幂等；需要幂等时引入幂等键或去重机制。
- **函数/类接口**:
  - 依赖倒置 (DIP): 上层模块不应依赖下层模块，二者都应依赖于抽象（接口）。
  - 接口隔离 (ISP): 使用多个专门的接口，而不是一个臃肿的通用接口。
  - 版本化策略：接口变更需可演进（新字段向后兼容、旧字段废弃周期、必要时版本化）。

---

## 4. 数据流管理方案 (Data Flow Management)

- **单向数据流**: 尤其在前端应用中，保持数据流向清晰可追踪。
- **DTO (Data Transfer Objects)**:
  - 在层与层之间传输数据时，使用 DTO 而不是原始的数据库实体对象。
  - 防止内部数据结构的泄露。
- **不可变性 (Immutability)**:
  - 尽可能使用不可变数据结构传递数据，减少副作用和并发问题。
 - **事件与副作用**:
   - 核心流程与副作用（通知、统计、异步任务）解耦，优先事件/消息驱动。
   - 事件载荷使用稳定契约（DTO），避免携带内部对象引用。

---

## 5. 扩展性设计考虑 (Extensibility Design)

- **开闭原则 (OCP)**: 软件实体应对扩展开放，对修改关闭。通过添加新代码来实现新功能，而不是修改现有代码。
- **插件化架构**: 对于可能频繁变更或增加的功能（如支付网关、导出格式），设计插件接口，允许动态加载或配置不同的实现。
- **配置驱动**: 业务规则中的可变参数（如税率、超时时间）应提取到配置文件或数据库配置中，避免硬编码。
- **事件驱动**: 使用发布/订阅模式解耦核心流程和辅助流程（如：下单成功后 -> 发送邮件、统计数据），提高系统的灵活性。

---

## 6. 常见反例与纠偏

- **反例：Controller 写业务逻辑** → 纠偏：将编排与规则下沉到 Service/Use Case，仅保留参数/鉴权/响应转换
- **反例：Service 直接操作 ORM/SDK** → 纠偏：抽象 Repository/Client 接口，集中处理 I/O 细节与可观测性
- **反例：跨模块互相 import 私有实现** → 纠偏：暴露稳定的接口与 DTO，内部实现保持私有
- **反例：实体/DTO 混用导致泄露内部字段** → 纠偏：显式定义 DTO 与映射逻辑，输出层仅返回响应 DTO
